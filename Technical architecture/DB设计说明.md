## 1. DB设计原则

数据库设计范式是一系列**规范化规则**，用于减少数据冗余、避免数据异常（插入异常、更新异常、删除异常），并确保数据依赖关系的合理性。遵循这些范式有助于设计出结构良好、高效且易于维护的数据库。

以下是主要的范式及其核心思想和要求：

1.  **第一范式**
    
    *   **核心要求：** 确保每个列的属性值都是**原子的**。
    *   **规则：**
        *   表中的每一列都只包含单一值。
        *   每一列的值都是不可再分的基本数据项（例如，不能是数组、列表或包含多个值的组合字段）。
        *   没有重复的列组。
    *   **解决的问题：** 消除重复组，使数据具有基本的结构。
    *   **例子：** 如果一个“订单”表有一个“产品”列，里面存储了多个产品ID（如 "P001, P002"），这违反了1NF。应将其拆分成单独的“订单明细”行，每行只包含一个产品ID。
    
2.  **第二范式**
    *   **前提条件：** 表必须已满足1NF。
    *   **核心要求：** 消除**非主属性**对**候选键**的**部分函数依赖**。
    *   **规则：**
        *   表必须满足1NF。
        *   表中的所有非主属性必须**完全函数依赖**于整个候选键。
    *   **解释：**
        *   **候选键：** 能够唯一标识表中一行的一个或一组属性。
        *   **主属性：** 包含在任何候选键中的属性。
        *   **非主属性：** 不包含在任何候选键中的属性。
        *   **部分函数依赖：** 非主属性只依赖于候选键的一部分，而不是整个候选键。
    *   **解决的问题：** 当表有复合主键时，避免非主属性只依赖于部分主键造成的冗余和更新异常。
    *   **例子：** 考虑一个“订单明细”表，主键是（订单ID, 产品ID）。如果表中还包含“客户姓名”字段，而“客户姓名”只依赖于“订单ID”（一个订单只有一个客户），而不是依赖于整个主键（订单ID + 产品ID）。这违反了2NF。应将“客户姓名”移到以“订单ID”为主键的“订单”表中。

3.  **第三范式**
    
    *   **前提条件：** 表必须已满足2NF。
    *   **核心要求：** 消除**非主属性**之间的**传递函数依赖**。
    *   **规则：**
        *   表必须满足2NF。
        *   所有非主属性都**必须直接函数依赖**于候选键（即不能存在非主属性A依赖于非主属性B，而B又依赖于候选键的情况）。
    *   **解释：**
        *   **传递函数依赖：** 如果 A → B 且 B → C（B 不 → A），那么 A → C 是一个传递依赖。
    *   **解决的问题：** 进一步减少冗余和更新异常。避免非主属性之间相互依赖导致修改一个属性需要修改多处。
    *   **例子：** 考虑一个“员工”表，包含（员工ID, 部门ID, 部门名称, 部门地点）。主键是员工ID。员工ID → 部门ID，部门ID → 部门名称和部门地点。因此，“部门名称”和“部门地点”传递依赖于“员工ID”（通过“部门ID”）。这违反了3NF。应将部门信息（部门ID, 部门名称, 部门地点）拆分到单独的“部门”表中。
    
4.  **巴斯-科德范式**
    
    *   **前提条件：** 表必须已满足3NF。
    *   **核心要求：** 消除**主属性**对**非候选键属性**的依赖（即消除所有非平凡且非函数依赖的多值依赖）。
    *   **规则：**
        *   表必须满足3NF。
        *   对于表中的每一个非平凡的函数依赖 X → Y：
            *   X 必须是超键（包含候选键的属性集），或者
            *   Y 必须是主属性（包含在某个候选键中的属性）。
    *   **解决的问题：** 3NF有时无法处理某些特殊情况（主属性部分依赖或传递依赖于候选键）。BCNF 是比 3NF 更严格的范式，能解决这些残留问题。
    *   **例子：** 考虑一个“学生选课-教师”表（假设一个教师只教一门课）：（学号, 课程, 教师）。假设依赖关系是：
            *   学号, 课程 → 教师
                *   教师 → 课程
        
        *   候选键是（学号, 课程）和（学号, 教师）。
        *   非主属性？这里没有非主属性（所有属性都是主属性）。
        *   存在依赖：教师 → 课程。这里的决定因子“教师”**不是超键**（仅凭教师无法唯一确定一行，因为一个教师可能有多个学生），而“课程”**也不是主属性**（它被函数依赖决定，但它本身是主属性？在BCNF规则中，要求Y必须是主属性*或者*X是超键。这里X(教师)不是超键，Y(课程)是主属性吗？需要仔细分析：在这个表里，课程是主属性（因为它包含在候选键（学号, 课程）中）。但关键是：`教师 → 课程` 这个依赖违反了BCNF的规则，因为决定因子`教师`**不是超键**。这可能导致异常：如果教师更改所教课程，需要更新多处。应拆分成（学号, 教师）和（教师, 课程）两个表。
    
5.  **第四范式**
    
    *   **前提条件：** 表必须已满足BCNF。
    *   **核心要求：** 消除**非平凡的多值依赖**。
    *   **规则：**
        *   表必须满足BCNF。
        *   对于表中的每一个非平凡的多值依赖 X →→ Y，X 必须是超键。
    *   **解决的问题：** 处理独立的多值事实，避免冗余。多值依赖是指当X确定时，Y有一组独立的值与之对应，且这组值与另一个属性Z无关（只要Z也依赖于X）。
    *   **例子：** 考虑一个“医生-患者-专业”表：（医生ID, 患者ID, 专业）。假设一个医生有多个专业，同时治疗多个患者，并且医生治疗某患者与他的专业无关（即医生用所有专业治疗所有患者）。这隐含了多值依赖：医生ID →→ 患者ID 和 医生ID →→ 专业。如果医生ID不是超键（仅凭医生ID不能唯一确定一行），这违反了4NF。应拆分成（医生ID, 患者ID）和（医生ID, 专业）两个表。
    
6.  **第五范式**
    
    *   **前提条件：** 表必须已满足4NF。
    *   **核心要求：** 消除**连接依赖**。
    *   **规则：**
        *   表必须满足4NF。
        *   表不能被无损分解成两个以上的投影（子表），除非这些投影包含原始表的候选键。
    *   **解决的问题：** 处理非常复杂的、隐含的关联关系，这些关系通过分解成三个或更多表才能无损失地重构。这种情况在实际数据库设计中非常罕见。
    *   **例子：** 非常抽象和复杂，通常涉及三个属性之间所有可能的二元关系都需要存在才能重构原始表。如果一个表描述代理商、产品和公司之间的销售关系，并且满足特定条件（每个代理商销售所有公司的所有产品？），可能需要分解成三个两两关系的表。

**总结与关键点：**

*   **渐进性：** 范式是递进的，满足更高范式的前提是满足所有较低范式（1NF -> 2NF -> 3NF -> BCNF -> 4NF -> 5NF）。
*   **目的：**
    *   减少数据冗余。
    *   避免数据操作异常（插入异常、更新异常、删除异常）。
    *   增强数据一致性和完整性。
    *   使数据结构更清晰、更灵活。
*   **权衡：** 并非范式越高越好！过度规范化可能导致：
    *   需要过多的表连接（JOIN）操作来获取完整信息，降低查询性能。
    *   设计过于复杂，难以理解和维护。
*   **实际应用：** 在大多数联机事务处理系统中，**满足第三范式**是一个常见的、合理的平衡点。有时为了优化特定查询的性能（尤其是在数据仓库或报表系统中），会有意地进行**反规范化**，即引入一些冗余或放松范式约束。
*   **工具而非目标：** 范式是设计和评估数据库结构的有力工具，但它们不是绝对的教条。最终目标是设计出满足业务需求、性能良好、易于维护且能保证数据完整性的数据库。

--------------------------

## 2.设计说明

MySQL和SQLite的区别

SQLite 和 MySQL 都是流行的关系型数据库管理系统 (RDBMS)，但它们在架构、设计目标、适用场景上存在显著差异。以下是它们的主要区别：

## 核心区别概览

| 特性           | SQLite                                   | MySQL                                     |
| :------------- | :--------------------------------------- | :---------------------------------------- |
| **架构**       | **无服务器、嵌入式**                     | **客户端-服务器**                         |
| **数据库形式** | 单个磁盘文件 (`.sqlite`, `.db`)          | 通常由多个文件/目录组成 (表空间、日志等)  |
| **进程模型**   | **库** (与应用同进程)                    | **独立守护进程** (`mysqld`)               |
| **网络访问**   | 无 (需通过文件系统或应用层共享)          | 原生网络协议 (TCP/IP, Unix socket)        |
| **并发模型**   | **库级锁** (写独占)                      | **行级锁** (InnoDB), 多线程               |
| **部署复杂度** | **零配置**                               | 需要安装、配置、管理服务                  |
| **主要优势**   | 轻量、简单、快速、无依赖、单文件         | 高性能、高并发、功能丰富、可扩展、安全    |
| **典型场景**   | 移动应用、桌面软件、小型Web、IoT、嵌入式 | Web应用、企业级系统、高并发服务、数据仓库 |

---

## 详细对比

1.  **架构与部署**
    *   **SQLite:**
        *   **嵌入式数据库：** 它不是一个独立运行的服务器进程，而是一个 **C语言库**，直接 **链接到应用程序中**。应用程序通过函数调用直接读写磁盘上的数据库文件。
        *   **无服务器：** 不需要安装、配置或管理数据库服务器。
        *   **单文件数据库：** 整个数据库（表、索引、数据）存储在主机操作系统的一个单一文件中。备份和传输极其简单（复制文件即可）。
        *   **零配置：** 开箱即用，几乎不需要管理。
    *   **MySQL:**
        *   **客户端-服务器模型：** 有一个独立的数据库服务器守护进程 (`mysqld`)。应用程序（客户端）通过网络协议（通常是 TCP/IP 或 Unix socket）与服务器通信。
        *   **需要管理：** 必须安装、配置、启动、停止、维护服务器进程。需要管理用户权限、连接、内存、日志等。
        *   **多文件结构：** 数据库由多个文件组成（表空间文件、日志文件、配置文件等），通常存储在一个特定的目录下。

2.  **访问与并发**
    *   **SQLite:**
        *   **写锁：** 采用 **库级锁** 机制。当有写入操作时，会锁定整个数据库文件（写独占），此时其他写入操作会被阻塞。读取操作可以并发进行（只要没有写锁）。**在高并发写入场景下性能会急剧下降**。
        *   **单点访问：** 最适合单个进程/线程访问，或者多个进程/线程以 **只读** 方式访问。多进程写入同一文件需要谨慎协调（通常不推荐）。
    *   **MySQL:**
        *   **行级锁 (InnoDB)：** 默认存储引擎 InnoDB 支持 **行级锁定**。多个客户端可以同时读写数据库的不同行，极大提升了高并发场景下的性能。
        *   **多连接：** 服务器进程处理来自多个客户端的并发连接请求，内置线程池优化资源利用。
        *   **网络访问：** 原生支持远程访问，客户端可以轻松地通过网络连接到数据库服务器。

3.  **可扩展性与性能**
    *   **SQLite:**
        *   **轻量级：** 库非常小（几百KB），资源消耗极低（内存、CPU）。
        *   **本地访问快：** 对于单用户或低并发访问，因为省去了网络通信和进程间通信的开销，**本地读写操作通常非常快**。
        *   **扩展性有限：** **不适合高并发写入或超大规模数据集**。库级锁是主要瓶颈。数据集大小受限于文件系统和磁盘（理论很大，但实际管理超大文件效率可能降低）。
    *   **MySQL:**
        *   **高性能：** 经过高度优化，能够处理非常高的读写负载和海量数据（TB/PB级）。
        *   **高并发：** 行级锁和多线程架构使其能有效支持成百上千的并发连接。
        *   **可扩展性强：** 支持主从复制、分片（Sharding）、集群（如 InnoDB Cluster, NDB Cluster）等方案来扩展读写能力和存储容量。
        *   **网络开销：** 网络通信会带来一定延迟。

4.  **特性与功能**
    *   **SQLite:**
        *   **标准 SQL 支持：** 支持大多数标准的 SQL92 特性，包括事务（ACID）、视图、触发器、部分 ALTER TABLE。
        *   **数据类型亲和性：** 使用动态类型（值有类型，列无严格类型约束），更灵活但也可能带来隐式类型转换。
        *   **功能相对精简：** 缺少一些高级功能，如复杂的用户权限管理（只有文件系统权限）、存储过程、自定义函数扩展较复杂、没有内置的复制或高可用方案。
    *   **MySQL:**
        *   **丰富的 SQL 支持：** 支持更广泛的 SQL 标准（包括更多 SQL99 及以后特性）和大量扩展。
        *   **严格数据类型：** 支持丰富的严格数据类型（INT, VARCHAR, TEXT, BLOB, DATE/TIME, ENUM, SET, JSON 等）。
        *   **高级功能：** 强大的用户账户和精细的权限系统、存储过程、函数、触发器、事件调度器、视图、外键约束（InnoDB）、全文搜索、空间数据支持 (GIS)。
        *   **多种存储引擎：** 插件式架构支持不同存储引擎（如 InnoDB - 事务安全, MyISAM - 读密集, Memory - 内存表等），可根据场景选择。
        *   **复制与高可用：** 原生支持主从复制、组复制等，提供高可用性和读扩展能力。

5.  **适用场景**
    *   **SQLite 是理想选择：**
        *   移动应用 (Android, iOS)
        *   桌面应用程序 (浏览器、媒体播放器、办公软件内部存储)
        *   嵌入式系统和物联网设备
        *   小型网站或低流量 Web 应用（作为文件数据库）
        *   应用程序缓存或本地存储
        *   数据分析的中间格式（单文件易于分发）
        *   测试或开发环境快速原型验证
        *   需要单文件、零配置、无依赖的场景
    *   **MySQL 是理想选择：**
        *   中大型网站和 Web 应用（LAMP/LEMP 栈核心组件）
        *   需要高并发读写的应用（电商、社交平台）
        *   多用户客户端需要同时访问数据库的应用
        *   需要复杂查询、事务完整性、外键约束的应用
        *   需要精细用户权限管理和安全控制的系统
        *   需要数据库复制、高可用性、负载均衡或分片的场景
        *   企业级应用和数据仓库
        *   需要利用丰富 SQL 特性和存储过程的应用

6.  **管理与运维**
    *   **SQLite:**
        *   **极简管理：** 几乎无需管理。备份就是复制数据库文件。
        *   **无用户管理：** 依赖文件系统的访问权限。
    *   **MySQL:**
        *   **需要专业 DBA：** 安装、配置优化、备份恢复、监控、用户权限管理、性能调优、安全加固、版本升级等都需要专业知识和管理工具。
        *   **强大工具链：** 提供丰富的命令行工具 (`mysql`, `mysqldump`, `mysqladmin`) 和图形化管理工具 (MySQL Workbench, phpMyAdmin 等)。

---

## 总结

*   **SQLite 是嵌入式引擎：** 追求 **极致简单、轻量、零管理、单文件**。它是 **应用的亲密伙伴**，适合本地存储、单用户或低并发场景。优势在于部署简单和本地访问速度。
*   **MySQL 是数据库服务器：** 追求 **高性能、高并发、功能完备、可扩展、安全可控**。它是 **数据服务的提供者**，适合多用户、高负载、需要网络访问和高级特性的生产环境。优势在于处理能力和丰富的企业级功能。

**选择？**

*   如果你的应用是移动端、桌面端、嵌入式设备，或者是一个简单的、低流量、单机部署的小型网站/工具，并且你希望部署和管理尽可能简单，**SQLite** 是非常好的选择。
*   如果你的应用是多用户的 Web 服务、需要处理高并发请求、涉及复杂的数据操作和事务、需要严格的安全性和用户管理、或者未来需要扩展（复制、分片），那么 **MySQL** (或其同类如 PostgreSQL) 是更合适的选择。

- MySQL

  >一开始设计之初使用的是mysql数据库，但是考虑组内成员的掌握和使用情况，统一改成sqlite

- SQLite

  >考虑到开发的需要，以及我们的项目的使用情况，最终采用了SQLite



### 争对SQLite表结构设计

#### 一共分为两个数据库

- organization

  > 包含四个表
  >
  > - invitations
  >   - 成员邀请情况
  > - join_requests
  >   - 加入组织申请
  > - organization_members
  >   - 组织成员
  > - organizations	
  >   - 组织

- schedule_planner

  >包含七个表
  >
  >- meeting_participants
  >  - 会议参与人员
  >- meetings
  >  - 会议
  >- recurring_events
  >  - 事项频次记录
  >- schedule_events
  >  - 时间日程安排
  >- token_blacklist
  >  - 存储token
  >- users
  >  - 用户表
  >- verification_codes
  >  - 验证码

